// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	time "time"

	bug "github.com/MichaelMure/git-bug/bug"
	models "github.com/MichaelMure/git-bug/graphql/models"
	operations "github.com/MichaelMure/git-bug/operations"
	git "github.com/MichaelMure/git-bug/util/git"
	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	AddCommentOperation_date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error)

	Bug_status(ctx context.Context, obj *bug.Snapshot) (models.Status, error)

	Bug_lastEdit(ctx context.Context, obj *bug.Snapshot) (time.Time, error)
	Bug_comments(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.CommentConnection, error)
	Bug_operations(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.OperationConnection, error)

	CreateOperation_date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error)

	LabelChangeOperation_date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error)

	Mutation_newBug(ctx context.Context, repoRef *string, title string, message string, files []git.Hash) (bug.Snapshot, error)
	Mutation_addComment(ctx context.Context, repoRef *string, prefix string, message string, files []git.Hash) (bug.Snapshot, error)
	Mutation_changeLabels(ctx context.Context, repoRef *string, prefix string, added []string, removed []string) (bug.Snapshot, error)
	Mutation_open(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	Mutation_close(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	Mutation_setTitle(ctx context.Context, repoRef *string, prefix string, title string) (bug.Snapshot, error)
	Mutation_commit(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)

	Query_defaultRepository(ctx context.Context) (*models.Repository, error)
	Query_repository(ctx context.Context, id string) (*models.Repository, error)

	Repository_allBugs(ctx context.Context, obj *models.Repository, after *string, before *string, first *int, last *int, query *string) (models.BugConnection, error)
	Repository_bug(ctx context.Context, obj *models.Repository, prefix string) (*bug.Snapshot, error)

	SetStatusOperation_date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error)
	SetStatusOperation_status(ctx context.Context, obj *operations.SetStatusOperation) (models.Status, error)

	SetTitleOperation_date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error)
}

type ResolverRoot interface {
	AddCommentOperation() AddCommentOperationResolver
	Bug() BugResolver
	CreateOperation() CreateOperationResolver
	LabelChangeOperation() LabelChangeOperationResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	SetStatusOperation() SetStatusOperationResolver
	SetTitleOperation() SetTitleOperationResolver
}
type AddCommentOperationResolver interface {
	Date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error)
}
type BugResolver interface {
	Status(ctx context.Context, obj *bug.Snapshot) (models.Status, error)

	LastEdit(ctx context.Context, obj *bug.Snapshot) (time.Time, error)
	Comments(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.CommentConnection, error)
	Operations(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.OperationConnection, error)
}
type CreateOperationResolver interface {
	Date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error)
}
type LabelChangeOperationResolver interface {
	Date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error)
}
type MutationResolver interface {
	NewBug(ctx context.Context, repoRef *string, title string, message string, files []git.Hash) (bug.Snapshot, error)
	AddComment(ctx context.Context, repoRef *string, prefix string, message string, files []git.Hash) (bug.Snapshot, error)
	ChangeLabels(ctx context.Context, repoRef *string, prefix string, added []string, removed []string) (bug.Snapshot, error)
	Open(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	Close(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
	SetTitle(ctx context.Context, repoRef *string, prefix string, title string) (bug.Snapshot, error)
	Commit(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error)
}
type QueryResolver interface {
	DefaultRepository(ctx context.Context) (*models.Repository, error)
	Repository(ctx context.Context, id string) (*models.Repository, error)
}
type RepositoryResolver interface {
	AllBugs(ctx context.Context, obj *models.Repository, after *string, before *string, first *int, last *int, query *string) (models.BugConnection, error)
	Bug(ctx context.Context, obj *models.Repository, prefix string) (*bug.Snapshot, error)
}
type SetStatusOperationResolver interface {
	Date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error)
	Status(ctx context.Context, obj *operations.SetStatusOperation) (models.Status, error)
}
type SetTitleOperationResolver interface {
	Date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) AddCommentOperation_date(ctx context.Context, obj *operations.AddCommentOperation) (time.Time, error) {
	return s.r.AddCommentOperation().Date(ctx, obj)
}

func (s shortMapper) Bug_status(ctx context.Context, obj *bug.Snapshot) (models.Status, error) {
	return s.r.Bug().Status(ctx, obj)
}

func (s shortMapper) Bug_lastEdit(ctx context.Context, obj *bug.Snapshot) (time.Time, error) {
	return s.r.Bug().LastEdit(ctx, obj)
}

func (s shortMapper) Bug_comments(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.CommentConnection, error) {
	return s.r.Bug().Comments(ctx, obj, after, before, first, last)
}

func (s shortMapper) Bug_operations(ctx context.Context, obj *bug.Snapshot, after *string, before *string, first *int, last *int) (models.OperationConnection, error) {
	return s.r.Bug().Operations(ctx, obj, after, before, first, last)
}

func (s shortMapper) CreateOperation_date(ctx context.Context, obj *operations.CreateOperation) (time.Time, error) {
	return s.r.CreateOperation().Date(ctx, obj)
}

func (s shortMapper) LabelChangeOperation_date(ctx context.Context, obj *operations.LabelChangeOperation) (time.Time, error) {
	return s.r.LabelChangeOperation().Date(ctx, obj)
}

func (s shortMapper) Mutation_newBug(ctx context.Context, repoRef *string, title string, message string, files []git.Hash) (bug.Snapshot, error) {
	return s.r.Mutation().NewBug(ctx, repoRef, title, message, files)
}

func (s shortMapper) Mutation_addComment(ctx context.Context, repoRef *string, prefix string, message string, files []git.Hash) (bug.Snapshot, error) {
	return s.r.Mutation().AddComment(ctx, repoRef, prefix, message, files)
}

func (s shortMapper) Mutation_changeLabels(ctx context.Context, repoRef *string, prefix string, added []string, removed []string) (bug.Snapshot, error) {
	return s.r.Mutation().ChangeLabels(ctx, repoRef, prefix, added, removed)
}

func (s shortMapper) Mutation_open(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error) {
	return s.r.Mutation().Open(ctx, repoRef, prefix)
}

func (s shortMapper) Mutation_close(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error) {
	return s.r.Mutation().Close(ctx, repoRef, prefix)
}

func (s shortMapper) Mutation_setTitle(ctx context.Context, repoRef *string, prefix string, title string) (bug.Snapshot, error) {
	return s.r.Mutation().SetTitle(ctx, repoRef, prefix, title)
}

func (s shortMapper) Mutation_commit(ctx context.Context, repoRef *string, prefix string) (bug.Snapshot, error) {
	return s.r.Mutation().Commit(ctx, repoRef, prefix)
}

func (s shortMapper) Query_defaultRepository(ctx context.Context) (*models.Repository, error) {
	return s.r.Query().DefaultRepository(ctx)
}

func (s shortMapper) Query_repository(ctx context.Context, id string) (*models.Repository, error) {
	return s.r.Query().Repository(ctx, id)
}

func (s shortMapper) Repository_allBugs(ctx context.Context, obj *models.Repository, after *string, before *string, first *int, last *int, query *string) (models.BugConnection, error) {
	return s.r.Repository().AllBugs(ctx, obj, after, before, first, last, query)
}

func (s shortMapper) Repository_bug(ctx context.Context, obj *models.Repository, prefix string) (*bug.Snapshot, error) {
	return s.r.Repository().Bug(ctx, obj, prefix)
}

func (s shortMapper) SetStatusOperation_date(ctx context.Context, obj *operations.SetStatusOperation) (time.Time, error) {
	return s.r.SetStatusOperation().Date(ctx, obj)
}

func (s shortMapper) SetStatusOperation_status(ctx context.Context, obj *operations.SetStatusOperation) (models.Status, error) {
	return s.r.SetStatusOperation().Status(ctx, obj)
}

func (s shortMapper) SetTitleOperation_date(ctx context.Context, obj *operations.SetTitleOperation) (time.Time, error) {
	return s.r.SetTitleOperation().Date(ctx, obj)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var addCommentOperationImplementors = []string{"AddCommentOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddCommentOperation(ctx context.Context, sel []query.Selection, obj *operations.AddCommentOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, addCommentOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddCommentOperation")
		case "author":
			out.Values[i] = ec._AddCommentOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._AddCommentOperation_date(ctx, field, obj)
		case "message":
			out.Values[i] = ec._AddCommentOperation_message(ctx, field, obj)
		case "files":
			out.Values[i] = ec._AddCommentOperation_files(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AddCommentOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AddCommentOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _AddCommentOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "AddCommentOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.AddCommentOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _AddCommentOperation_message(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AddCommentOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AddCommentOperation_files(ctx context.Context, field graphql.CollectedField, obj *operations.AddCommentOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AddCommentOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Files()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

var bugImplementors = []string{"Bug"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Bug(ctx context.Context, sel []query.Selection, obj *bug.Snapshot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bug")
		case "id":
			out.Values[i] = ec._Bug_id(ctx, field, obj)
		case "humanId":
			out.Values[i] = ec._Bug_humanId(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Bug_status(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Bug_title(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Bug_labels(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Bug_author(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Bug_createdAt(ctx, field, obj)
		case "lastEdit":
			out.Values[i] = ec._Bug_lastEdit(ctx, field, obj)
		case "comments":
			out.Values[i] = ec._Bug_comments(ctx, field, obj)
		case "operations":
			out.Values[i] = ec._Bug_operations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Bug_id(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Id()
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_humanId(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HumanId()
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_status(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_status(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.Status)
		return res
	})
}

func (ec *executionContext) _Bug_title(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Bug_labels(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Labels
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _Bug_author(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _Bug_createdAt(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bug"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.CreatedAt
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _Bug_lastEdit(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_lastEdit(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _Bug_comments(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := field.Args["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_comments(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.CommentConnection)
		return ec._CommentConnection(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Bug_operations(ctx context.Context, field graphql.CollectedField, obj *bug.Snapshot) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := field.Args["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Bug",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Bug_operations(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.OperationConnection)
		return ec._OperationConnection(ctx, field.Selections, &res)
	})
}

var bugConnectionImplementors = []string{"BugConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugConnection(ctx context.Context, sel []query.Selection, obj *models.BugConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugConnection")
		case "edges":
			out.Values[i] = ec._BugConnection_edges(ctx, field, obj)
		case "nodes":
			out.Values[i] = ec._BugConnection_nodes(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._BugConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._BugConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _BugConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._BugEdge(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _BugConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Nodes
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Bug(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _BugConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _BugConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.BugConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var bugEdgeImplementors = []string{"BugEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BugEdge(ctx context.Context, sel []query.Selection, obj *models.BugEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bugEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BugEdge")
		case "cursor":
			out.Values[i] = ec._BugEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._BugEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _BugEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.BugEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _BugEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.BugEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BugEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._Bug(ctx, field.Selections, &res)
}

var commentImplementors = []string{"Comment", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Comment(ctx context.Context, sel []query.Selection, obj *bug.Comment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Comment")
		case "author":
			out.Values[i] = ec._Comment_author(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Comment_message(ctx, field, obj)
		case "files":
			out.Values[i] = ec._Comment_files(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Comment_author(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Comment"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _Comment_message(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Comment"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Comment_files(ctx context.Context, field graphql.CollectedField, obj *bug.Comment) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Comment"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Files
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

var commentConnectionImplementors = []string{"CommentConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentConnection(ctx context.Context, sel []query.Selection, obj *models.CommentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentConnection")
		case "edges":
			out.Values[i] = ec._CommentConnection_edges(ctx, field, obj)
		case "nodes":
			out.Values[i] = ec._CommentConnection_nodes(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._CommentConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._CommentConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CommentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._CommentEdge(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _CommentConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Nodes
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Comment(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _CommentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _CommentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.CommentConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var commentEdgeImplementors = []string{"CommentEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CommentEdge(ctx context.Context, sel []query.Selection, obj *models.CommentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, commentEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentEdge")
		case "cursor":
			out.Values[i] = ec._CommentEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._CommentEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CommentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.CommentEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _CommentEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.CommentEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CommentEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._Comment(ctx, field.Selections, &res)
}

var createOperationImplementors = []string{"CreateOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CreateOperation(ctx context.Context, sel []query.Selection, obj *operations.CreateOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, createOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateOperation")
		case "author":
			out.Values[i] = ec._CreateOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._CreateOperation_date(ctx, field, obj)
		case "title":
			out.Values[i] = ec._CreateOperation_title(ctx, field, obj)
		case "message":
			out.Values[i] = ec._CreateOperation_message(ctx, field, obj)
		case "files":
			out.Values[i] = ec._CreateOperation_files(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _CreateOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _CreateOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "CreateOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.CreateOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _CreateOperation_title(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

func (ec *executionContext) _CreateOperation_message(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	return graphql.MarshalString(res)
}

func (ec *executionContext) _CreateOperation_files(ctx context.Context, field graphql.CollectedField, obj *operations.CreateOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "CreateOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Files()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

var labelChangeOperationImplementors = []string{"LabelChangeOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _LabelChangeOperation(ctx context.Context, sel []query.Selection, obj *operations.LabelChangeOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, labelChangeOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelChangeOperation")
		case "author":
			out.Values[i] = ec._LabelChangeOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._LabelChangeOperation_date(ctx, field, obj)
		case "added":
			out.Values[i] = ec._LabelChangeOperation_added(ctx, field, obj)
		case "removed":
			out.Values[i] = ec._LabelChangeOperation_removed(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _LabelChangeOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _LabelChangeOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "LabelChangeOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.LabelChangeOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _LabelChangeOperation_added(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Added
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _LabelChangeOperation_removed(ctx context.Context, field graphql.CollectedField, obj *operations.LabelChangeOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "LabelChangeOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Removed
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return res[idx1]
		}())
	}
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "newBug":
			out.Values[i] = ec._Mutation_newBug(ctx, field)
		case "addComment":
			out.Values[i] = ec._Mutation_addComment(ctx, field)
		case "changeLabels":
			out.Values[i] = ec._Mutation_changeLabels(ctx, field)
		case "open":
			out.Values[i] = ec._Mutation_open(ctx, field)
		case "close":
			out.Values[i] = ec._Mutation_close(ctx, field)
		case "setTitle":
			out.Values[i] = ec._Mutation_setTitle(ctx, field)
		case "commit":
			out.Values[i] = ec._Mutation_commit(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_newBug(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["title"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["title"] = arg1
	var arg2 string
	if tmp, ok := field.Args["message"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["message"] = arg2
	var arg3 []git.Hash
	if tmp, ok := field.Args["files"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			}
		}
		arg3 = make([]git.Hash, len(rawIf1))
		for idx1 := range rawIf1 {
			err = (&arg3[idx1]).UnmarshalGQL(rawIf1[idx1])
		}
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["files"] = arg3
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_newBug(ctx, args["repoRef"].(*string), args["title"].(string), args["message"].(string), args["files"].([]git.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_addComment(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	var arg2 string
	if tmp, ok := field.Args["message"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["message"] = arg2
	var arg3 []git.Hash
	if tmp, ok := field.Args["files"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			}
		}
		arg3 = make([]git.Hash, len(rawIf1))
		for idx1 := range rawIf1 {
			err = (&arg3[idx1]).UnmarshalGQL(rawIf1[idx1])
		}
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["files"] = arg3
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_addComment(ctx, args["repoRef"].(*string), args["prefix"].(string), args["message"].(string), args["files"].([]git.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_changeLabels(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	var arg2 []string
	if tmp, ok := field.Args["added"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			}
		}
		arg2 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg2[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["added"] = arg2
	var arg3 []string
	if tmp, ok := field.Args["removed"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			}
		}
		arg3 = make([]string, len(rawIf1))
		for idx1 := range rawIf1 {
			arg3[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
		}
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["removed"] = arg3
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_changeLabels(ctx, args["repoRef"].(*string), args["prefix"].(string), args["added"].([]string), args["removed"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_open(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_open(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_close(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_close(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_setTitle(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	var arg2 string
	if tmp, ok := field.Args["title"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["title"] = arg2
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_setTitle(ctx, args["repoRef"].(*string), args["prefix"].(string), args["title"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_commit(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["repoRef"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repoRef"] = arg0
	var arg1 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_commit(ctx, args["repoRef"].(*string), args["prefix"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bug.Snapshot)
	return ec._Bug(ctx, field.Selections, &res)
}

var operationConnectionImplementors = []string{"OperationConnection"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationConnection(ctx context.Context, sel []query.Selection, obj *models.OperationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, operationConnectionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationConnection")
		case "edges":
			out.Values[i] = ec._OperationConnection_edges(ctx, field, obj)
		case "nodes":
			out.Values[i] = ec._OperationConnection_nodes(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OperationConnection_pageInfo(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._OperationConnection_totalCount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OperationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Edges
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._OperationEdge(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _OperationConnection_nodes(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Nodes
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Operation(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _OperationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PageInfo
	return ec._PageInfo(ctx, field.Selections, &res)
}

func (ec *executionContext) _OperationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.OperationConnection) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationConnection"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.TotalCount
	return graphql.MarshalInt(res)
}

var operationEdgeImplementors = []string{"OperationEdge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OperationEdge(ctx context.Context, sel []query.Selection, obj *models.OperationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, operationEdgeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OperationEdge")
		case "cursor":
			out.Values[i] = ec._OperationEdge_cursor(ctx, field, obj)
		case "node":
			out.Values[i] = ec._OperationEdge_node(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OperationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.OperationEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _OperationEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.OperationEdge) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OperationEdge"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Node
	return ec._Operation(ctx, field.Selections, &res)
}

var pageInfoImplementors = []string{"PageInfo"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PageInfo(ctx context.Context, sel []query.Selection, obj *models.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, pageInfoImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HasNextPage
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.HasPreviousPage
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.StartCursor
	return graphql.MarshalString(res)
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "PageInfo"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EndCursor
	return graphql.MarshalString(res)
}

var personImplementors = []string{"Person"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Person(ctx context.Context, sel []query.Selection, obj *bug.Person) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, personImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Person")
		case "email":
			out.Values[i] = ec._Person_email(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Person_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Person_email(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Email
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_name(ctx context.Context, field graphql.CollectedField, obj *bug.Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "defaultRepository":
			out.Values[i] = ec._Query_defaultRepository(ctx, field)
		case "repository":
			out.Values[i] = ec._Query_repository(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_defaultRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_defaultRepository(ctx)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Repository)
		if res == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query_repository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_repository(ctx, args["id"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Repository)
		if res == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var repositoryImplementors = []string{"Repository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Repository(ctx context.Context, sel []query.Selection, obj *models.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, repositoryImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "allBugs":
			out.Values[i] = ec._Repository_allBugs(ctx, field, obj)
		case "bug":
			out.Values[i] = ec._Repository_bug(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Repository_allBugs(ctx context.Context, field graphql.CollectedField, obj *models.Repository) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["after"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["after"] = arg0
	var arg1 *string
	if tmp, ok := field.Args["before"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["before"] = arg1
	var arg2 *int
	if tmp, ok := field.Args["first"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := field.Args["last"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := field.Args["query"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["query"] = arg4
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_allBugs(ctx, obj, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["query"].(*string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.BugConnection)
		return ec._BugConnection(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Repository_bug(ctx context.Context, field graphql.CollectedField, obj *models.Repository) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["prefix"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["prefix"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_bug(ctx, obj, args["prefix"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*bug.Snapshot)
		if res == nil {
			return graphql.Null
		}
		return ec._Bug(ctx, field.Selections, res)
	})
}

var setStatusOperationImplementors = []string{"SetStatusOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetStatusOperation(ctx context.Context, sel []query.Selection, obj *operations.SetStatusOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, setStatusOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetStatusOperation")
		case "author":
			out.Values[i] = ec._SetStatusOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SetStatusOperation_date(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SetStatusOperation_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SetStatusOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetStatusOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _SetStatusOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetStatusOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _SetStatusOperation_status(ctx context.Context, field graphql.CollectedField, obj *operations.SetStatusOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetStatusOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetStatusOperation_status(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.Status)
		return res
	})
}

var setTitleOperationImplementors = []string{"SetTitleOperation", "Operation", "Authored"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SetTitleOperation(ctx context.Context, sel []query.Selection, obj *operations.SetTitleOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, setTitleOperationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetTitleOperation")
		case "author":
			out.Values[i] = ec._SetTitleOperation_author(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SetTitleOperation_date(ctx, field, obj)
		case "title":
			out.Values[i] = ec._SetTitleOperation_title(ctx, field, obj)
		case "was":
			out.Values[i] = ec._SetTitleOperation_was(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SetTitleOperation_author(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetTitleOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Author
	return ec._Person(ctx, field.Selections, &res)
}

func (ec *executionContext) _SetTitleOperation_date(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SetTitleOperation",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SetTitleOperation_date(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(time.Time)
		return graphql.MarshalTime(res)
	})
}

func (ec *executionContext) _SetTitleOperation_title(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetTitleOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Title
	return graphql.MarshalString(res)
}

func (ec *executionContext) _SetTitleOperation_was(ctx context.Context, field graphql.CollectedField, obj *operations.SetTitleOperation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SetTitleOperation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Was
	return graphql.MarshalString(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Authored(ctx context.Context, sel []query.Selection, obj *models.Authored) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case bug.Comment:
		return ec._Comment(ctx, sel, &obj)
	case *bug.Comment:
		return ec._Comment(ctx, sel, obj)
	case operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Operation(ctx context.Context, sel []query.Selection, obj *bug.Operation) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, &obj)
	case *operations.CreateOperation:
		return ec._CreateOperation(ctx, sel, obj)
	case operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, &obj)
	case *operations.SetTitleOperation:
		return ec._SetTitleOperation(ctx, sel, obj)
	case operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, &obj)
	case *operations.AddCommentOperation:
		return ec._AddCommentOperation(ctx, sel, obj)
	case operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, &obj)
	case *operations.SetStatusOperation:
		return ec._SetStatusOperation(ctx, sel, obj)
	case operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, &obj)
	case *operations.LabelChangeOperation:
		return ec._LabelChangeOperation(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`scalar Time
scalar Label
scalar Hash

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!
  # When paginating backwards, the cursor to continue.
  startCursor: String!
  # When paginating forwards, the cursor to continue.
  endCursor: String!
}

# Represents an person in a git object.
type Person {
  # The email of the person.
  email: String

  # The name of the person.
  name: String
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

# Represents a comment on a bug.
type Comment implements Authored {
  # The author of this comment.
  author: Person!

  # The message of this comment.
  message: String!

  # All media's hash referenced in this comment
  files: [Hash!]!
}

enum Status {
  OPEN
  CLOSED
}

# An object that has an author.
interface Authored {
  # The author of this object.
  author: Person!
}

type OperationConnection {
  edges: [OperationEdge!]!
  nodes: [Operation!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OperationEdge {
  cursor: String!
  node: Operation!
}

# An operation applied to a bug.
interface Operation {
  # The operations author.
  author: Person!
  # The datetime when this operation was issued.
  date: Time!
}

type CreateOperation implements Operation, Authored {
  author: Person!
  date: Time!

  title: String!
  message: String!
  files: [Hash!]!
}

type SetTitleOperation implements Operation, Authored {
  author: Person!
  date: Time!

  title: String!
  was: String!
}

type AddCommentOperation implements Operation, Authored {
  author: Person!
  date: Time!

  message: String!
  files: [Hash!]!
}

type SetStatusOperation implements Operation, Authored {
  author: Person!
  date: Time!

  status: Status!
}

type LabelChangeOperation implements Operation, Authored {
  author: Person!
  date: Time!

  added: [Label!]!
  removed: [Label!]!
}

# The connection type for Bug.
type BugConnection {
  # A list of edges.
  edges: [BugEdge!]!
  nodes: [Bug!]!
  # Information to aid in pagination.
  pageInfo: PageInfo!
  # Identifies the total count of items in the connection.
  totalCount: Int!
}

# An edge in a connection.
type BugEdge {
  # A cursor for use in pagination.
  cursor: String!
  # The item at the end of the edge.
  node: Bug!
}

type Bug {
  id: String!
  humanId: String!
  status: Status!
  title: String!
  labels: [Label!]!
  author: Person!
  createdAt: Time!
  lastEdit: Time!

  comments(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    # Returns the elements in the list that come before the specified cursor.
    before: String
    # Returns the first _n_ elements from the list.
    first: Int
    # Returns the last _n_ elements from the list.
    last: Int
  ): CommentConnection!

  operations(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    # Returns the elements in the list that come before the specified cursor.
    before: String
    # Returns the first _n_ elements from the list.
    first: Int
    # Returns the last _n_ elements from the list.
    last: Int
  ): OperationConnection!
}

type Repository {
  allBugs(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    # Returns the elements in the list that come before the specified cursor.
    before: String
    # Returns the first _n_ elements from the list.
    first: Int
    # Returns the last _n_ elements from the list.
    last: Int
    # A query to select and order bugs
    query: String
  ): BugConnection!
  bug(prefix: String!): Bug
}

type Query {
  defaultRepository: Repository
  repository(id: String!): Repository
}

type Mutation {
  newBug(repoRef: String, title: String!, message: String!, files: [Hash!]): Bug!

  addComment(repoRef: String, prefix: String!, message: String!, files: [Hash!]): Bug!
  changeLabels(repoRef: String, prefix: String!, added: [String!], removed: [String!]): Bug!
  open(repoRef: String, prefix: String!): Bug!
  close(repoRef: String, prefix: String!): Bug!
  setTitle(repoRef: String, prefix: String!, title: String!): Bug!

  commit(repoRef: String, prefix: String!): Bug!
}
`)
